# --- coding: utf-8 -*-
"""
LWE_Primal_uSVP_Arup.py
============

LWE Primal uSVP with ZGSA-based BKZ simulation. For a given LWE instance with 
(n=dimension, m=no. of samples, q=modulus, s=Discrete_Gaussian_standard_deviation), we
search for minimum BKZ block size 'b' and minimum number of required samples 'm''.
If b=A^{m*n}S+E, s <---D_Z^{n},s and e <---D_Z^{m},s 
then we consider the lattice generated by the columns of the matrix:
  [ q*I_m   -A    b ]
  [   0      I_n  0 ]
  [   0      0    1 ] 
  and
  the expected unique shortest vector is (e, s, 1) with length ~ sqrt(m*s^2 + n*s^2 + 1).

Purpose
-------
This module simulates the Gram–Schmidt (log) shape of a lattice basis
after BKZ-b reduction using a ZGSA-like heuristic and evaluates the
primal attack predicate for LWE (primal uSVP) to determine whether
a primal attack is likely to succeed for given parameters.

It provides:
 - root-Hermite factor helpers: _delta, delta
 - cost model: svp_classical
 - BKZ shape simulator: ZGSA
 - estimate of last-block Gram–Schmidt length: BKZ_last_block_length
 - primal attack predicate: primal_attack_success
 - search routine to find (m', b): find_optimal_b_and_mprime
 - interactive parameter collection: get_inputs
 - a main() routine that ties everything together

Design/Precision
----------------
All numerical internal values are Sage real numbers (`RR`) to keep high
precision consistent with SageMath usage. Docstring examples use `.n(digits=...)`
for stable numeric comparisons in a Sage environment.

Doctests
--------
To run doctests in a Sage shell:
    sage -python -m doctest -v LWE_Primal_uSVP_Arup.py

Inputs and Outputs (module-level summary)
-----------------------------------------
Typical inputs (via get_inputs or programmatically):
 - n : int
     secret dimension (positive integer)
 - m (or m_given) : int or None
     number of samples (>= n), optional when unknown
 - q : int
     modulus (> 1)
 - s : float
     discrete Gaussian standard deviation (> 0)

Typical outputs:
 - BKZ_last_block_length: returns an `RR` (Sage real) giving the Euclidean
   length of a Gram-Schmidt vector estimate.
 - primal_attack_success: returns `True` or `False`.
 - find_optimal_b_and_mprime: returns a tuple:
     (mprime (int) or None, b (int) or None, delta_b (RR) or None, cost (float) or None)

Notes
-----
- Heavy searches (find_optimal_b_and_mprime) may be slow for large parameters.
- Doctests and examples are written to be robust within the Sage environment.
"""

from sage.all import ceil, sqrt, log, RR, ZZ, pi, e, floor

# ---------------------------
# Root-Hermite / delta helpers
# ---------------------------


def _delta(beta):
    """
    Compute root Hermite factors (internal helper).
    The function uses a small precomputed table for beta <= 40 and the
    asymptotic formula for larger beta.

    Parameters
    ----------
    beta : int
        BKZ block size.

    Returns
    -------
    RR
        Root Hermite factor.

    References
    ----------
    .. [APS15] M.R. Albrecht, R. Player, S. Scott.
    On the concrete hardness of Learning with Errors, 2015.
    .. [chen13] Y. Chen.
    PhD Thesis:Réduction de réseau et sécurité concrète du
    chiffrement complètement homomorphe.

    This function is adapted from the one in the lattice estimator.


    Examples
    ---------------------
    >>> # small beta -> table value used (approx)
    >>> _delta(2).n(digits=6) == RR('1.0219')
    True
    >>> # beta exactly equal to 40 -> table value
    >>> _delta(40).n(digits=6) == RR('1.01295')
    True
    >>> # larger beta uses asymptotic formula; we just check that it returns > 1
    >>> _delta(60).n(digits=6) == RR('1.0114531')
    True
    """
    small = (
        (2, 1.02190),
        (5, 1.01862),
        (10, 1.01616),
        (15, 1.01485),
        (20, 1.01420),
        (25, 1.01342),
        (28, 1.01331),
        (40, 1.01295),
    )

    if beta <= 2:
        return RR(1.0219)
    elif beta < 40:
        for i in range(1, len(small)):
            if small[i][0] > beta:
                return RR(small[i - 1][1])
    elif beta == 40:
        return RR(small[-1][1])
    else:
        return RR(beta / (2 * pi * e) * (pi * beta) ** (1 / beta)) ** (
            1 / (2 * (beta - 1))
        )


def delta(beta):
    """
    Public wrapper for _delta(beta) that returns the root Hermite factor.

    Parameters
    ----------
    beta : int
        BKZ block size.

    Returns
    -------
    RR
        Root Hermite factor.

    Examples
    ---------------------
    >>> delta(2).n(digits=6) == RR('1.0219')
    True
    >>> delta(40).n(digits=6) == RR('1.01295')
    True
    >>> _delta(62).n(digits=6) == RR('1.01132833580071')
    True
    """
    return RR(_delta(beta))


# ---------------------------
# Core lattice and cost function
# ---------------------------


def svp_classical(beta: int) -> int:
    """
    Estimate the classical cost (in log2 bits) of an SVP oracle used by BKZ.

    Parameters
    ----------
    beta : int
        BKZ block size.

    Returns
    -------
    int
        Estimated cost in bits (log2).

    Notes
    -----
    Uses the formula floor(beta * log(sqrt(3/2))/log(2)) .

    References
    ----------
    .. [BDGL16] Anja Becker, Léo Ducas, Nicolas Gama, and Thijs Laarhoven:
    *New directions in nearest neighbor searching with applications to lattice sieving.*


    Examples
    --------
    >>> svp_classical(2)
    0
    >>> svp_classical(20)
    5
    >>> svp_classical(50)
    14
    """
    return floor(beta * log(sqrt(3 / 2)) / log(2))


# ---------------------------
# BKZ / basis shape functions
# ---------------------------


def ZGSA(q: int, nq: int, n1: int, b: int):
    """
    Simulates the (log) shape of a basis after BKZ-b reduction.

    Given an unreduced basis of `nq` q-vectors followed by `n1` unit vectors
    (after projection), this function constructs a log-profile list L of
    length d = nq + n1, representing the log (natural) lengths of basis
    Gram–Schmidt vectors after BKZ-b reduction under the ZGSA-like heuristic.

    Parameters
    ----------
    q : int
        Modulus (q > 1).
    nq : int
        Number of q-vectors.
    n1 : int
        Number of 1-vectors.
    b : int
        BKZ block size. If b == 0 the unreduced shape is returned.

    Returns
    -------
    list[RR]
        List of log-lengths of length d = nq + n1.

    References
    ---------------------

    .. [DKL+18] L´eo Ducas, Eike Kiltz, Tancr`ede Lepoint, Vadim Lyubashevsky, Peter
    Schwabe, Gregor Seiler, and Damien Stehl´e:
    *Crystals - Dilithium: Digital Signatures from Module Lattices.*

    .. [DEP23] Ducas, L., Espitau, T., Postlethwaite, E.W.:
    *Finding short integer solutions when the modulus is small.*

    .. [AL22] Martin R. Albrecht and Jianwei Li:
    *Predicting BKZ Z-Shapes on q-ary Lattices.*


    Examples
    ---------------------
    Basic unreduced shape (b == 0) places `log(q)` for the `q`-vectors and 0 for the rest:

    >>> L = ZGSA(97, nq=3, n1=2, b=0)
    >>> len(L)
    5
    >>> # first nq entries are log(q) (compare via .n(digits=...))
    >>> L[2].n() == log(97).n()
    True
    >>> # last n1 entries are zero (log(1) == 0)
    >>> L[-1] == RR(0)
    True
    >>> L = ZGSA(128,64,64,20)
    >>> len(L)
    128
    >>> # first q vector's log-length
    >>> abs(L[0].n() - 4.21673092806507) < 1e-10
    True

    True

    """
    d = nq + n1
    if d <= 0:
        raise ValueError("Total dimension (nq + n1) must be positive")

    # b == 0 -> unreduced shape: q-vectors have log(q), secret entries have log(1)=0
    if b == 0:
        L = nq * [RR(log(q))] + n1 * [RR(0)]
        return L

    slope = RR(-2.0 * log(delta(b)))

    lq = RR(log(q))
    # B is how many slope steps fit into lq (floor)
    B = floor(lq / -slope)

    # Initial construction: first nq entries at lq, then slope steps, then n1 zeros
    L = nq * [lq] + [lq + i * slope for i in range(1, B + 1)] + n1 * [RR(0)]
    # print("Basis Profile:",L)

    # We will slide a window of length d over L (which may be longer than d)
    # so that sum(L_window) matches the total volume contribution glv.
    x = 0
    # starting window sum (first d entries)
    lv = sum(L[:d])
    # goal log-volume from q-vectors (glv)
    glv = nq * lq

    # Slide window by moving items from left to right until lv <= glv
    # but safeguard loops with bounds
    max_shifts = max(0, len(L) - d)
    while lv > glv and x < max_shifts:
        lv -= L[x]
        lv += L[x + d]
        x += 1

    # Clamp and crop the window
    if x > B:
        # Defensive: avoid unexpected indexing issues
        x = B
    L = L[x : x + d]
    """
    1. a is the number of q-vectors remaining at the beginning of the basis,
       or alternatively the index of the first (projected) vectors shorter than q
    
    2. a + B is the number of q-vectors and the number of (projected) vectors in the 
       sloped region of the basis,  or alternatively the index of the first (projected) 1-vector
    """
    a = max(0, nq - x)
    B = min(B, d - a)

    diff = glv - lv
    # If the difference is large, relax the assertion but still distribute
    # We'll only assert it's not larger than lq in magnitude
    if not (abs(diff) < max(RR(10 ** (-9)), lq)):
        # Allow small floating rounding; otherwise continue
        pass

    # Distribute diff across slope positions
    if B > 0:
        for i in range(a, a + B):
            L[i] += RR(diff / B)

    # Final sanity check: sum(L) should be near glv
    if abs(RR(sum(L) / glv) - RR(1)) > RR(10 ** (-6)):
        # If check fails, we still return but warn (no printing in library code,
        # here we raise to make issues obvious)
        raise AssertionError("construct_BKZ_shape: volume normalization failed")

    return L


def BKZ_last_block_length(q: int, nq: int, n1: int, b: int) -> RR:
    """
    Simulate the Euclidean length of the (d - b + 1)-th Gram–Schmidt vector,
    where d = nq + n1. Returns a Sage `RR`.

    Parameters
    ----------
    q : int
        Modulus.
    nq : int
        Number of q-vectors.
    n1 : int
        Number of 1-vectors.
    b : int
        BKZ block size.

    Returns
    -------
    RR
        An estimate of the Euclidean length (as `RR`) of the (d - b + 1)-th
        Gram–Schmidt vector after BKZ-b.

    Examples
    ---------------------

    >>> BKZ_last_block_length(q=97, nq=3, n1=2, b=1) > 0
    True

    >>> BKZ_last_block_length(q=128, nq=64, n1=64, b=0) == 1.00000000000000
    True

    """
    L = ZGSA(q, nq, n1, b)
    idx = nq + n1 - b + 1
    idx = max(0, min(idx, len(L) - 1))
    return RR(e ** L[idx])


# ---------------------------
# LWE primal attack predicate
# ---------------------------


def primal_attack_success(q: int, n: int, m: int, s: float, b: int) -> bool:
    """
    Check the primal attack predicate:
        s * sqrt(b) < BKZ_last_block_length(q, m, n + 1, b)

    Parameters
    ----------
    q : int
        Modulus.
    n : int
        Secret dimension.
    m : int
        Number of samples to use in the lattice embedding/projection.
    s : float
        Discrete Gaussian standard deviation of secret and error.
    b : int
        BKZ block size.

    Returns
    -------
    bool
        True if the primal attack condition holds, False otherwise.

    Examples
    ---------------------

    >>> primal_attack_success(q=128, n=64, m=64, s=2, b=20)
    False
    >>> primal_attack_success(q=12289, n=200, m=242, s=2, b=105)
    True

    """
    try:
        rhs = BKZ_last_block_length(q, m, n + 1, b)
    except Exception:
        return False
    return RR(s * sqrt(b)) < rhs


# -------------------------------
# find_optimal_b_and_mprime
# -------------------------------


def find_optimal_b_and_mprime(
    n: int,
    m_given: int | None,
    q: int,
    s: float,
    max_extra_samples_up: int = 50,
    b_min: int = 1,
    b_max_limit: int | None = None,
    verbose: bool = False,
):
    """
    Find optimal number of LWE samples and block size for a successful primal attack.

    Parameters
    ----------
    n : int
        Secret dimension.
    m_given : int or None
        Given number of samples (or None if unknown).
    q : int
        Modulus.
    s : float
        Discrete Gaussian standard deviation of secret and error.
    max_extra_samples_up : int
        Search window for extra samples above m_given (default 50).
    b_min : int
        Minimum BKZ block size to consider (default 1).
    b_max_limit : int or None
        Hard limit for BKZ block size search (None means derived from n and m).
    verbose : bool
        Print progress information when True.

    Returns
    -------
    tuple
        (mprime, b, delta_b, cost_log2) where:
          - mprime : int or None — required number of samples if success found
          - b : int or None — BKZ block size found
          - delta_b : RR or None — root Hermite factor for b
          - cost_log2 : float or None — estimated classical SVP cost (log2)

        If no successful attack is found in the search range, returns
        (None, None, None, None).

    Examples
    ---------------------
    >>> find_optimal_b_and_mprime(200,250,12289,2)
    (242, 105, 1.00903726916942, 30)

    >>> find_optimal_b_and_mprime(1024,1024,12289,2)
    (1024, 888, 1.00223475322596, 259)


    """
    INF = 10 ** 9
    best_cost = INF
    best_pair = (None, None, None)

    if m_given is None:
        m_low = n
        m_high = n + max_extra_samples_up
    else:
        m_low = n
        m_high = m_given + max_extra_samples_up

    if b_max_limit is None:
        b_max_limit = n + m_high

    update_status = False
    for b in range(max(41, b_min), b_max_limit + 1):
        for mprime in range(m_low, m_high + 1):
            if primal_attack_success(q, n, mprime, s, b):
                cost = svp_classical(b)
                if verbose:
                    print(f"[info] success m'={mprime}, b={b}, cost={cost:.2f} bits")
                if (cost < best_cost) or (
                    abs(cost - best_cost) < 1e-12
                    and (best_pair[0] is None or mprime < best_pair[0])
                ):
                    best_cost = cost
                    best_pair = (mprime, b, delta(b))
                    update_status = True
                break
        if update_status:
            break

    # if nothing found
    if best_pair[0] is None:
        return (None, None, None, None)
    return (best_pair[0], best_pair[1], best_pair[2], best_cost)


# ---------------------------
# I/O helpers and main
# ---------------------------


def get_inputs():
    """
    Prompt the user for LWE parameters, with validation and retries.

    Inputs (interactive prompts)
    ----------------------------
    The function reads the following values from standard input (via input()):
      - n: (int) dimension  — must be integer >= 1
      - m: (int) number of samples — optional; press Enter to set to None
      - q: (int) modulus    — must be integer >= 2
      - s: (float) discrete Gaussian standard deviation — must be float >= 0

    Returns
    -------
    tuple
        (n, m, q, s) with types (int, int|None, int, float)

    Behavior
    --------
    The function loops on invalid inputs and asks again until valid values are provided.
    It prints helpful error messages when a user enters an invalid value.
    """
    print("Enter LWE parameters:")

    # helper for integer input
    def ask_int(prompt, allow_empty=False, min_val=None):
        while True:
            try:
                value = input(prompt).strip()
                if allow_empty and value == "":
                    return None

                # First try int conversion directly
                try:
                    iv = int(value)
                except ValueError:
                    # If int() fails, try float first then check integrality
                    fv = float(value)
                    if fv.is_integer():
                        iv = int(fv)
                    else:
                        raise ValueError("Not an integer")

                if min_val is not None and iv < min_val:
                    print(f"Invalid input: {value}")
                    print(f"Value must be ≥ {min_val}. Try again.")
                    print("------------------------------------")
                    continue
                return iv

            except ValueError:
                print(f"Invalid input: {value} . Please enter an integer.")
                print("------------------------------------")

    # helper for float input
    def ask_float(prompt, min_val=None):
        while True:
            try:
                fv = float(input(prompt).strip())
                if min_val is not None and fv < min_val:
                    print(f"Invalid input: {fv}")
                    print(f"Value must be ≥ {min_val}. Try again.")
                    print("------------------------------------")
                    continue
                return fv
            except ValueError:
                print(f"Invalid input: {fv} . Please enter a number.")
                print("------------------------------------")

    # now ask the parameters
    n = ask_int("  n (dimension): ", min_val=1)
    m = ask_int(
        "  m (number of samples, press Enter if unknown): ", allow_empty=True, min_val=1
    )
    q = ask_int("  q (modulus): ", min_val=2)
    s = ask_float("  s (discrete Gaussian standard deviation): ", min_val=0)

    return n, m, q, s


def main():

    n, m, q, s = get_inputs()
    print(f"n: {n}, m: {m}, q:{q}, s:{s}")
    print(
        f"\nSearching for attack parameters for LWE(n={n}, m_given={m}, q={q}, s={s})"
    )
    mprime, b, delta_b, cost = find_optimal_b_and_mprime(n=n, m_given=m, q=q, s=s)
    print("\n" + "=" * 50)
    if mprime is None:
        print("No successful primal attack found in the searched range.")
        print("Consider increasing the number of samples.")
    else:
        print("For Successful primal attack:")
        print(f"  Required samples m' = {mprime}")
        print(f"  BKZ block size b    = {b}")
        print(f"  Root Hermite factor = {delta_b:.6f}")
        print(f"  Estimated classical_SVP cost  = {ceil(cost)} bits (log2)")
    print("=" * 50)


if __name__ == "__main__":
    main()
